// *****************************************************************************
//
//  Copyright (c) Konstantin Geist. All rights reserved.
//
//  The use and distribution terms for this software are contained in the file
//  named License.txt, which can be found in the root of this distribution.
//  By using this software in any fashion, you are agreeing to be bound by the
//  terms of this license.
//
//  You must not remove this notice, or any other, from this software.
//
// *****************************************************************************

#include <execinfo.h>
#include "../../Application.h"
#include "../../Domain.h"

namespace skizo { namespace script {
using namespace skizo::core;

struct NativeStackFrame {
    NativeStackFrame* NextFrame;
    void* FunctionAddress;
};

static bool isFunctionTCCOrThunkJITGenerated(CDomain* domain, void* ptr)
{
    return domain->IsSymbol(ptr) || domain->ThunkManager().IsThunk(ptr);
}

/**
 * Our abort mechanism depends on C++ exceptions, however Linux' DWARF cannot unwind through foreign stack frames,
 * including our JIT-generated thunks and TCC-compiled code.
 * It just immediately crashes the entire process when it finds an unfamiliar stack frame.
 * The hack is to walk up the chain of EBP's and manually remove all foreign frames before throwing the abort exception.
 * This seems to be relatively safe because none of our generated frames contain any sort of cleanup code (everything
 * is GC-collected).
 *
 * This function is very DWARF-specific, it's very brittle and probably not very portable.
 */
void unwindHack(char* msg, bool free)
{
    CDomain* domain = CDomain::ForCurrentThread();

    NativeStackFrame* curFrame = (NativeStackFrame*)__builtin_frame_address(0);
    NativeStackFrame* prevFrame = nullptr;

    // Removes frames for functions generated by TCC and ThunkJIT.
    do {
        if(isFunctionTCCOrThunkJITGenerated(domain, curFrame->FunctionAddress)) {
            if(prevFrame) {
                prevFrame->NextFrame = curFrame->NextFrame;
            }
        } else {
            prevFrame = curFrame;
        }
    } while((curFrame = curFrame->NextFrame));

    // Let's check if foreign frames were successfully removed. If they were not, we should fail fast instead of crashing
    // with a core dump.
    curFrame = (NativeStackFrame*)__builtin_frame_address(0);
    do {
        if(isFunctionTCCOrThunkJITGenerated(domain, curFrame->FunctionAddress)) {
            // Fail fast. Note that failing fast is the last resort, because it leaves all reference-counted objects
            // unreleased (including their destructors) and all domains hosted in the current process are also abruptly
            // killed.
            printf("Aborted (fail fast): %s\n", msg);
            if(free) {
                CString::FreeUtf8(msg);
            }
            Application::Exit(1);
        }
    } while((curFrame = curFrame->NextFrame));
}

} }
